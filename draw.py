import numpy as np

# dataflow for this module will look like this
# (1) numpy array from picture module                                   --DONE
# (2) numpy array -> DFS -> list of paths                               --DONE
# (3) list of paths -> formatting -> list of path coords                --IP (will be this code)
# (4) list of path coords -> sawyer path                                --IP (hopefully lab 7 satisfies)

"""
projects a 2D image onto 3D page, returning the 3D path coords
input: numpy array of 1s and 0s (generated by the camera module)
output: A list of 3D paths
"""
def array_to_path(image):
    # DFS on the image array for list of 2D paths
    paths = dfs(image)
    print("2D image paths:\n", paths, "\n")

    # image characteristics
    image_width, image_height = image.shape

    # page characteristics
    corner_coord = (0, 0, 0) # manual calibration
    paper_len_x = .457 # 45.7cm
    paper_len_y = .305 # 30.5cm

    # pixel resolution using characteristics
    x_res = paper_len_x / image_width
    y_res = paper_len_y / image_height

    # lift the pen to not mark page
    lift_dist = .05

    # to be populated by triples (paths -> path coords)
    paths_coords = []
    for path in paths:
        path_coords = []
        for point in path:
            path_coords.extend([to3D(point, corner_coord, x_res, y_res)]) ### TODO add pen lifts ###
        paths_coords.append(path_coords)

    return paths_coords


def to3D(point, corner_coord, x_res, y_res):
    return (corner_coord[0] + point[0]*x_res, corner_coord[1] + point[1]*y_res, corner_coord[2])


"""
inputs: a numpy array
outputs: a 2D list of paths
"""
def dfs(image):
    image_width, image_height = image.shape
    paths = []
    unexplored = True
    while unexplored:
        unexplored = False
        # for each pixel in image
        for x in range(image_width):
            for y in range(image_height):
                # if pixel on
                if image[x][y] == 1:
                    unexplored = True
                    # add this pixel and neighbors to path
                    path = visit(image, x, y)
                    paths.append(path)
    return paths

"""
explore a point on the image array
"""
def visit(image, x, y):
    image_width, image_height = image.shape
    # add and turn off this pixel
    points = [(x, y)]
    image[x][y] = 0

    # For each of the 4 neighbors...
    neighbors = [(x, y + 1), (x + 1, y), (x - 1, y), (x , y - 1)]
    for x, y in neighbors:
        # Don't check pixels outside borders
        if x >= image_width or x < 0 or y >= image_height or y < 0:
            continue
        # Add recursive neighbors to path
        if image[x][y] == 1:
            points.extend(visit(image, x, y))
            return points
    return points


if __name__ == '__main__':
    image = np.random.choice([0,1], size = (5,5), p = [1./3, 2./3])
    print(image, "\n")
    print(array_to_path(image), "\n")